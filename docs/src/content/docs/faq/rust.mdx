---
title: "Why Rust?"
description: "Why is NativeLink build with Rust?"
pagefind: true
---

## Rust for safety and blazing speed ðŸ¦€

NativeLink, as a system, demands both speed and safety in its operation. Among
all the languages that are fast and non garbage collected, Rust stands out as the
only one that provides the necessary guarantees for writing asynchronous code
for multiple distributed systems that communicate over GRPC.

Rust's unique features make it an ideal choice for NativeLink. It offers
unparalleled safety and speed, which are critical for the efficient operation
of distributed systems. The language's memory safety without garbage
collection, zero-cost abstractions, and powerful static analysis tools
contribute to its robustness and reliability.

Moreover, the addition of the Tokio library to Rust's async ecosystem has
significantly enhanced its capabilities. Tokio is a Rust framework for
developing applications with asynchronous I/O, which is particularly useful
for systems like NativeLink that involve a lot of network communication.

Tokio provides the foundation that made NativeLink possible. It offers a
multi-threaded, work-stealing scheduler, non-blocking I/O, and enables
efficient, high-level asynchronous APIs. This has allowed us to build
NativeLink as a highly efficient, reliable, and scalable system.

In conclusion, Rust, with its speed, safety, and the powerful async ecosystem
provided by Tokio, has been instrumental in the development and success of
NativeLink.
